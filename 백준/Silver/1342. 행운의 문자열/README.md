# [Silver I] 행운의 문자열 - 1342 

[문제 링크](https://www.acmicpc.net/problem/1342) 

### 성능 요약

메모리: 113044 KB, 시간: 940 ms

### 분류

백트래킹, 브루트포스 알고리즘, 수학

### 제출 일자

2024년 1월 25일 21:33:11

### 문제 설명

<p>민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.</p>

### 입력 

 <p>첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.</p>

### 출력 

 <p>첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.</p>

# 풀이

백트래킹으로 주어진 배열의 알파벳들로 만들 수 있는 모든 순열을 생성하고,

순열을 생성하는 도중 해당 순열이 valid한지 검사하는 로직을 추가하여 valid한 경우에만 다음 재귀로 타고 들어간다.

이 때 같은 알파벳이 여러 개가 존재한다면 경우의 수가 달라진다.

고등학교 수학 (18학번 기준) 확률과 통계 과목에서 `같은 것이 있는 순열` 에 대해 배운 적이 있다.

```
n개 중 같은 것이 각각 p, q, r개씩 있을 때, n개를 모두 택하여 일렬로 배열하는 순열의 수는

n! / (p! * q! * ... * r!)

(단, p + q + ... + r = n)
```
여기서 아이디어를 얻어 전체 경우의 수를 같은 알파벳의 개수의 팩토리얼로 나누어서 리턴하였다.

### PyPy3 메모리 초과

재귀를 사용한 문제를 해결할 때 습관적으로 `sys.setrecursionlimit(10 ** 6)` 코드를 삽입했었는데,
PyPy3으로 백준에서 채점할 때 메모리 초과 때문에 통과되지 않는 문제가 있다. 이를 삭제하고 제출하면 통과된다.
